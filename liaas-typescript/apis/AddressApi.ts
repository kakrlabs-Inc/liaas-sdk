/* tslint:disable */
/* eslint-disable */
/**
 * KakrLabs-SDK-Creator
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateAddressdto,
  CreateMultiSignatureAddressdto,
  GenerateDefaultAddressdto,
  SignMessagedto,
  VerifyMessagedto,
} from '../models/index';
import {
    CreateAddressdtoFromJSON,
    CreateAddressdtoToJSON,
    CreateMultiSignatureAddressdtoFromJSON,
    CreateMultiSignatureAddressdtoToJSON,
    GenerateDefaultAddressdtoFromJSON,
    GenerateDefaultAddressdtoToJSON,
    SignMessagedtoFromJSON,
    SignMessagedtoToJSON,
    VerifyMessagedtoFromJSON,
    VerifyMessagedtoToJSON,
} from '../models/index';

export interface ApiAddressAddressBalanceGetRequest {
    nodeUrlOrApiAccessKey?: string;
    address?: string;
}

export interface ApiAddressAddressDetailsGetRequest {
    nodeUrlOrApiAccessKey?: string;
    walletName?: string;
    address?: string;
}

export interface ApiAddressAddressPrivateKeyGetRequest {
    nodeUrlOrApiAccessKey?: string;
    wallet?: string;
    encryptedPassphrase?: string;
    address?: string;
}

export interface ApiAddressAddressPrivateKeyV2GetRequest {
    nodeUrlOrApiAccessKey?: string;
    wallet?: string;
    mnemonics?: string;
    address?: string;
}

export interface ApiAddressAddressTransactionGetRequest {
    nodeUrlOrApiAccessKey?: string;
    address?: string;
    take?: number;
    skip?: number;
}

export interface ApiAddressCreateMutiSigAddressPostRequest {
    nodeUrlOrApiAccessKey?: string;
    walletName?: string;
    encryptedPassphrase?: string;
    createMultiSignatureAddressdto?: CreateMultiSignatureAddressdto;
}

export interface ApiAddressCreatePostRequest {
    nodeUrlOrApiAccessKey?: string;
    walletName?: string;
    encryptedPassphrase?: string;
    createAddressdto?: CreateAddressdto;
}

export interface ApiAddressGenerateDefaultAddressPostRequest {
    nodeUrlOrApiAccessKey?: string;
    walletName?: string;
    encryptedPassphrase?: string;
    generateDefaultAddressdto?: GenerateDefaultAddressdto;
}

export interface ApiAddressScreenAddressGetRequest {
    nodeUrlOrApiAccessKey?: string;
    wallet?: string;
    mnemonics?: string;
    address?: string;
}

export interface ApiAddressSignMessagePostRequest {
    nodeUrlOrApiAccessKey?: string;
    signMessagedto?: SignMessagedto;
}

export interface ApiAddressVerifyMessagePostRequest {
    nodeUrlOrApiAccessKey?: string;
    verifyMessagedto?: VerifyMessagedto;
}

/**
 * 
 */
export class AddressApi extends runtime.BaseAPI {

    /**
     * address balance - returns the confirmed and unconfirmed balance
     */
    async apiAddressAddressBalanceGetRaw(requestParameters: ApiAddressAddressBalanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['address'] != null) {
            queryParameters['address'] = requestParameters['address'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }


        let urlPath = `/api/Address/address-balance`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * address balance - returns the confirmed and unconfirmed balance
     */
    async apiAddressAddressBalanceGet(requestParameters: ApiAddressAddressBalanceGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressAddressBalanceGetRaw(requestParameters, initOverrides);
    }

    /**
     * Get address details. all address details are returned.
     */
    async apiAddressAddressDetailsGetRaw(requestParameters: ApiAddressAddressDetailsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['address'] != null) {
            queryParameters['address'] = requestParameters['address'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }

        if (requestParameters['walletName'] != null) {
            headerParameters['walletName'] = String(requestParameters['walletName']);
        }


        let urlPath = `/api/Address/address-details`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get address details. all address details are returned.
     */
    async apiAddressAddressDetailsGet(requestParameters: ApiAddressAddressDetailsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressAddressDetailsGetRaw(requestParameters, initOverrides);
    }

    /**
     * Get the address private key using encrypted passphrase
     */
    async apiAddressAddressPrivateKeyGetRaw(requestParameters: ApiAddressAddressPrivateKeyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['address'] != null) {
            queryParameters['address'] = requestParameters['address'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }

        if (requestParameters['wallet'] != null) {
            headerParameters['wallet'] = String(requestParameters['wallet']);
        }

        if (requestParameters['encryptedPassphrase'] != null) {
            headerParameters['encryptedPassphrase'] = String(requestParameters['encryptedPassphrase']);
        }


        let urlPath = `/api/Address/address-private-key`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get the address private key using encrypted passphrase
     */
    async apiAddressAddressPrivateKeyGet(requestParameters: ApiAddressAddressPrivateKeyGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressAddressPrivateKeyGetRaw(requestParameters, initOverrides);
    }

    /**
     * Get the address private key using mnemonics
     */
    async apiAddressAddressPrivateKeyV2GetRaw(requestParameters: ApiAddressAddressPrivateKeyV2GetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['address'] != null) {
            queryParameters['address'] = requestParameters['address'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }

        if (requestParameters['wallet'] != null) {
            headerParameters['wallet'] = String(requestParameters['wallet']);
        }

        if (requestParameters['mnemonics'] != null) {
            headerParameters['mnemonics'] = String(requestParameters['mnemonics']);
        }


        let urlPath = `/api/Address/address-private-key-v2`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get the address private key using mnemonics
     */
    async apiAddressAddressPrivateKeyV2Get(requestParameters: ApiAddressAddressPrivateKeyV2GetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressAddressPrivateKeyV2GetRaw(requestParameters, initOverrides);
    }

    /**
     * retruns all transactions of an address without wallet
     */
    async apiAddressAddressTransactionGetRaw(requestParameters: ApiAddressAddressTransactionGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['address'] != null) {
            queryParameters['address'] = requestParameters['address'];
        }

        if (requestParameters['take'] != null) {
            queryParameters['take'] = requestParameters['take'];
        }

        if (requestParameters['skip'] != null) {
            queryParameters['skip'] = requestParameters['skip'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }


        let urlPath = `/api/Address/address-transaction`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * retruns all transactions of an address without wallet
     */
    async apiAddressAddressTransactionGet(requestParameters: ApiAddressAddressTransactionGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressAddressTransactionGetRaw(requestParameters, initOverrides);
    }

    /**
     * Create a multi-signature address. this address created will be encrypted but cannot be imported to other wallets.
     */
    async apiAddressCreateMutiSigAddressPostRaw(requestParameters: ApiAddressCreateMutiSigAddressPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }

        if (requestParameters['walletName'] != null) {
            headerParameters['walletName'] = String(requestParameters['walletName']);
        }

        if (requestParameters['encryptedPassphrase'] != null) {
            headerParameters['encryptedPassphrase'] = String(requestParameters['encryptedPassphrase']);
        }


        let urlPath = `/api/Address/create-muti-sig-address`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMultiSignatureAddressdtoToJSON(requestParameters['createMultiSignatureAddressdto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a multi-signature address. this address created will be encrypted but cannot be imported to other wallets.
     */
    async apiAddressCreateMutiSigAddressPost(requestParameters: ApiAddressCreateMutiSigAddressPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressCreateMutiSigAddressPostRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new address in a particular wallet
     */
    async apiAddressCreatePostRaw(requestParameters: ApiAddressCreatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }

        if (requestParameters['walletName'] != null) {
            headerParameters['walletName'] = String(requestParameters['walletName']);
        }

        if (requestParameters['encryptedPassphrase'] != null) {
            headerParameters['encryptedPassphrase'] = String(requestParameters['encryptedPassphrase']);
        }


        let urlPath = `/api/Address/create`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAddressdtoToJSON(requestParameters['createAddressdto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new address in a particular wallet
     */
    async apiAddressCreatePost(requestParameters: ApiAddressCreatePostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressCreatePostRaw(requestParameters, initOverrides);
    }

    /**
     * Generate a default address for a wallet. This address can be imported to other wallets.
     */
    async apiAddressGenerateDefaultAddressPostRaw(requestParameters: ApiAddressGenerateDefaultAddressPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }

        if (requestParameters['walletName'] != null) {
            headerParameters['walletName'] = String(requestParameters['walletName']);
        }

        if (requestParameters['encryptedPassphrase'] != null) {
            headerParameters['encryptedPassphrase'] = String(requestParameters['encryptedPassphrase']);
        }


        let urlPath = `/api/Address/generate-default-address`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateDefaultAddressdtoToJSON(requestParameters['generateDefaultAddressdto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Generate a default address for a wallet. This address can be imported to other wallets.
     */
    async apiAddressGenerateDefaultAddressPost(requestParameters: ApiAddressGenerateDefaultAddressPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressGenerateDefaultAddressPostRaw(requestParameters, initOverrides);
    }

    /**
     * Screen address to check the validity of the address, iswitness or not, isScript or not , isMweb or not and also returns the scriptPubKey
     */
    async apiAddressScreenAddressGetRaw(requestParameters: ApiAddressScreenAddressGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['address'] != null) {
            queryParameters['address'] = requestParameters['address'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }

        if (requestParameters['wallet'] != null) {
            headerParameters['wallet'] = String(requestParameters['wallet']);
        }

        if (requestParameters['mnemonics'] != null) {
            headerParameters['mnemonics'] = String(requestParameters['mnemonics']);
        }


        let urlPath = `/api/Address/screen-address`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Screen address to check the validity of the address, iswitness or not, isScript or not , isMweb or not and also returns the scriptPubKey
     */
    async apiAddressScreenAddressGet(requestParameters: ApiAddressScreenAddressGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressScreenAddressGetRaw(requestParameters, initOverrides);
    }

    /**
     * sign a message with address private key
     */
    async apiAddressSignMessagePostRaw(requestParameters: ApiAddressSignMessagePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }


        let urlPath = `/api/Address/sign-message`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignMessagedtoToJSON(requestParameters['signMessagedto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * sign a message with address private key
     */
    async apiAddressSignMessagePost(requestParameters: ApiAddressSignMessagePostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressSignMessagePostRaw(requestParameters, initOverrides);
    }

    /**
     * verify signed message
     */
    async apiAddressVerifyMessagePostRaw(requestParameters: ApiAddressVerifyMessagePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['nodeUrlOrApiAccessKey'] != null) {
            headerParameters['nodeUrlOrApiAccessKey'] = String(requestParameters['nodeUrlOrApiAccessKey']);
        }


        let urlPath = `/api/Address/verify-message`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VerifyMessagedtoToJSON(requestParameters['verifyMessagedto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * verify signed message
     */
    async apiAddressVerifyMessagePost(requestParameters: ApiAddressVerifyMessagePostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAddressVerifyMessagePostRaw(requestParameters, initOverrides);
    }

}
