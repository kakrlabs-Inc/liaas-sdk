/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.CreateAddressdto
import org.openapitools.client.models.CreateMultiSignatureAddressdto
import org.openapitools.client.models.GenerateDefaultAddressdto
import org.openapitools.client.models.SignMessagedto
import org.openapitools.client.models.VerifyMessagedto

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class AddressApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * GET /api/Address/address-balance
     * address balance - returns the confirmed and unconfirmed balance
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param address  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressAddressBalanceGet(nodeUrlOrApiAccessKey: kotlin.String? = null, address: kotlin.String? = null) : Unit {
        val localVarResponse = apiAddressAddressBalanceGetWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, address = address)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/Address/address-balance
     * address balance - returns the confirmed and unconfirmed balance
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param address  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressAddressBalanceGetWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, address: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressAddressBalanceGetRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, address = address)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressAddressBalanceGet
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param address  (optional)
     * @return RequestConfig
     */
    fun apiAddressAddressBalanceGetRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, address: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/Address/address-balance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/Address/address-details
     * Get address details. all address details are returned.
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param address  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressAddressDetailsGet(nodeUrlOrApiAccessKey: kotlin.String? = null, walletName: kotlin.String? = null, address: kotlin.String? = null) : Unit {
        val localVarResponse = apiAddressAddressDetailsGetWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, address = address)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/Address/address-details
     * Get address details. all address details are returned.
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param address  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressAddressDetailsGetWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, address: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressAddressDetailsGetRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, address = address)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressAddressDetailsGet
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param address  (optional)
     * @return RequestConfig
     */
    fun apiAddressAddressDetailsGetRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, address: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        walletName?.apply { localVariableHeaders["walletName"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/Address/address-details",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/Address/address-private-key
     * Get the address private key using encrypted passphrase
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param encryptedPassphrase  (optional)
     * @param address  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressAddressPrivateKeyGet(nodeUrlOrApiAccessKey: kotlin.String? = null, wallet: kotlin.String? = null, encryptedPassphrase: kotlin.String? = null, address: kotlin.String? = null) : Unit {
        val localVarResponse = apiAddressAddressPrivateKeyGetWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, wallet = wallet, encryptedPassphrase = encryptedPassphrase, address = address)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/Address/address-private-key
     * Get the address private key using encrypted passphrase
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param encryptedPassphrase  (optional)
     * @param address  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressAddressPrivateKeyGetWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, wallet: kotlin.String?, encryptedPassphrase: kotlin.String?, address: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressAddressPrivateKeyGetRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, wallet = wallet, encryptedPassphrase = encryptedPassphrase, address = address)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressAddressPrivateKeyGet
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param encryptedPassphrase  (optional)
     * @param address  (optional)
     * @return RequestConfig
     */
    fun apiAddressAddressPrivateKeyGetRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, wallet: kotlin.String?, encryptedPassphrase: kotlin.String?, address: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        wallet?.apply { localVariableHeaders["wallet"] = this.toString() }
        encryptedPassphrase?.apply { localVariableHeaders["encryptedPassphrase"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/Address/address-private-key",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/Address/address-private-key-v2
     * Get the address private key using mnemonics
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param mnemonics  (optional)
     * @param address  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressAddressPrivateKeyV2Get(nodeUrlOrApiAccessKey: kotlin.String? = null, wallet: kotlin.String? = null, mnemonics: kotlin.String? = null, address: kotlin.String? = null) : Unit {
        val localVarResponse = apiAddressAddressPrivateKeyV2GetWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, wallet = wallet, mnemonics = mnemonics, address = address)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/Address/address-private-key-v2
     * Get the address private key using mnemonics
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param mnemonics  (optional)
     * @param address  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressAddressPrivateKeyV2GetWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, wallet: kotlin.String?, mnemonics: kotlin.String?, address: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressAddressPrivateKeyV2GetRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, wallet = wallet, mnemonics = mnemonics, address = address)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressAddressPrivateKeyV2Get
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param mnemonics  (optional)
     * @param address  (optional)
     * @return RequestConfig
     */
    fun apiAddressAddressPrivateKeyV2GetRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, wallet: kotlin.String?, mnemonics: kotlin.String?, address: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        wallet?.apply { localVariableHeaders["wallet"] = this.toString() }
        mnemonics?.apply { localVariableHeaders["mnemonics"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/Address/address-private-key-v2",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/Address/address-transaction
     * retruns all transactions of an address without wallet
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param address  (optional)
     * @param take  (optional, default to 10)
     * @param skip  (optional, default to 0)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressAddressTransactionGet(nodeUrlOrApiAccessKey: kotlin.String? = null, address: kotlin.String? = null, take: kotlin.Int? = 10, skip: kotlin.Int? = 0) : Unit {
        val localVarResponse = apiAddressAddressTransactionGetWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, address = address, take = take, skip = skip)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/Address/address-transaction
     * retruns all transactions of an address without wallet
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param address  (optional)
     * @param take  (optional, default to 10)
     * @param skip  (optional, default to 0)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressAddressTransactionGetWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, address: kotlin.String?, take: kotlin.Int?, skip: kotlin.Int?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressAddressTransactionGetRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, address = address, take = take, skip = skip)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressAddressTransactionGet
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param address  (optional)
     * @param take  (optional, default to 10)
     * @param skip  (optional, default to 0)
     * @return RequestConfig
     */
    fun apiAddressAddressTransactionGetRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, address: kotlin.String?, take: kotlin.Int?, skip: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/Address/address-transaction",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Address/create-muti-sig-address
     * Create a multi-signature address. this address created will be encrypted but cannot be imported to other wallets.
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param createMultiSignatureAddressdto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressCreateMutiSigAddressPost(nodeUrlOrApiAccessKey: kotlin.String? = null, walletName: kotlin.String? = null, encryptedPassphrase: kotlin.String? = null, createMultiSignatureAddressdto: CreateMultiSignatureAddressdto? = null) : Unit {
        val localVarResponse = apiAddressCreateMutiSigAddressPostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, encryptedPassphrase = encryptedPassphrase, createMultiSignatureAddressdto = createMultiSignatureAddressdto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Address/create-muti-sig-address
     * Create a multi-signature address. this address created will be encrypted but cannot be imported to other wallets.
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param createMultiSignatureAddressdto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressCreateMutiSigAddressPostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, encryptedPassphrase: kotlin.String?, createMultiSignatureAddressdto: CreateMultiSignatureAddressdto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressCreateMutiSigAddressPostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, encryptedPassphrase = encryptedPassphrase, createMultiSignatureAddressdto = createMultiSignatureAddressdto)

        return request<CreateMultiSignatureAddressdto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressCreateMutiSigAddressPost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param createMultiSignatureAddressdto  (optional)
     * @return RequestConfig
     */
    fun apiAddressCreateMutiSigAddressPostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, encryptedPassphrase: kotlin.String?, createMultiSignatureAddressdto: CreateMultiSignatureAddressdto?) : RequestConfig<CreateMultiSignatureAddressdto> {
        val localVariableBody = createMultiSignatureAddressdto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        walletName?.apply { localVariableHeaders["walletName"] = this.toString() }
        encryptedPassphrase?.apply { localVariableHeaders["encryptedPassphrase"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Address/create-muti-sig-address",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Address/create
     * Create a new address in a particular wallet
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param createAddressdto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressCreatePost(nodeUrlOrApiAccessKey: kotlin.String? = null, walletName: kotlin.String? = null, encryptedPassphrase: kotlin.String? = null, createAddressdto: CreateAddressdto? = null) : Unit {
        val localVarResponse = apiAddressCreatePostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, encryptedPassphrase = encryptedPassphrase, createAddressdto = createAddressdto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Address/create
     * Create a new address in a particular wallet
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param createAddressdto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressCreatePostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, encryptedPassphrase: kotlin.String?, createAddressdto: CreateAddressdto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressCreatePostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, encryptedPassphrase = encryptedPassphrase, createAddressdto = createAddressdto)

        return request<CreateAddressdto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressCreatePost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param createAddressdto  (optional)
     * @return RequestConfig
     */
    fun apiAddressCreatePostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, encryptedPassphrase: kotlin.String?, createAddressdto: CreateAddressdto?) : RequestConfig<CreateAddressdto> {
        val localVariableBody = createAddressdto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        walletName?.apply { localVariableHeaders["walletName"] = this.toString() }
        encryptedPassphrase?.apply { localVariableHeaders["encryptedPassphrase"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Address/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Address/generate-default-address
     * Generate a default address for a wallet. This address can be imported to other wallets.
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param generateDefaultAddressdto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressGenerateDefaultAddressPost(nodeUrlOrApiAccessKey: kotlin.String? = null, walletName: kotlin.String? = null, encryptedPassphrase: kotlin.String? = null, generateDefaultAddressdto: GenerateDefaultAddressdto? = null) : Unit {
        val localVarResponse = apiAddressGenerateDefaultAddressPostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, encryptedPassphrase = encryptedPassphrase, generateDefaultAddressdto = generateDefaultAddressdto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Address/generate-default-address
     * Generate a default address for a wallet. This address can be imported to other wallets.
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param generateDefaultAddressdto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressGenerateDefaultAddressPostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, encryptedPassphrase: kotlin.String?, generateDefaultAddressdto: GenerateDefaultAddressdto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressGenerateDefaultAddressPostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, encryptedPassphrase = encryptedPassphrase, generateDefaultAddressdto = generateDefaultAddressdto)

        return request<GenerateDefaultAddressdto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressGenerateDefaultAddressPost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param generateDefaultAddressdto  (optional)
     * @return RequestConfig
     */
    fun apiAddressGenerateDefaultAddressPostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, encryptedPassphrase: kotlin.String?, generateDefaultAddressdto: GenerateDefaultAddressdto?) : RequestConfig<GenerateDefaultAddressdto> {
        val localVariableBody = generateDefaultAddressdto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        walletName?.apply { localVariableHeaders["walletName"] = this.toString() }
        encryptedPassphrase?.apply { localVariableHeaders["encryptedPassphrase"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Address/generate-default-address",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/Address/screen-address
     * Screen address to check the validity of the address, iswitness or not, isScript or not , isMweb or not and also returns the scriptPubKey
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param mnemonics  (optional)
     * @param address  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressScreenAddressGet(nodeUrlOrApiAccessKey: kotlin.String? = null, wallet: kotlin.String? = null, mnemonics: kotlin.String? = null, address: kotlin.String? = null) : Unit {
        val localVarResponse = apiAddressScreenAddressGetWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, wallet = wallet, mnemonics = mnemonics, address = address)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/Address/screen-address
     * Screen address to check the validity of the address, iswitness or not, isScript or not , isMweb or not and also returns the scriptPubKey
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param mnemonics  (optional)
     * @param address  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressScreenAddressGetWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, wallet: kotlin.String?, mnemonics: kotlin.String?, address: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressScreenAddressGetRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, wallet = wallet, mnemonics = mnemonics, address = address)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressScreenAddressGet
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param wallet  (optional)
     * @param mnemonics  (optional)
     * @param address  (optional)
     * @return RequestConfig
     */
    fun apiAddressScreenAddressGetRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, wallet: kotlin.String?, mnemonics: kotlin.String?, address: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (address != null) {
                    put("address", listOf(address.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        wallet?.apply { localVariableHeaders["wallet"] = this.toString() }
        mnemonics?.apply { localVariableHeaders["mnemonics"] = this.toString() }
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/Address/screen-address",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Address/sign-message
     * sign a message with address private key
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param signMessagedto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressSignMessagePost(nodeUrlOrApiAccessKey: kotlin.String? = null, signMessagedto: SignMessagedto? = null) : Unit {
        val localVarResponse = apiAddressSignMessagePostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, signMessagedto = signMessagedto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Address/sign-message
     * sign a message with address private key
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param signMessagedto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressSignMessagePostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, signMessagedto: SignMessagedto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressSignMessagePostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, signMessagedto = signMessagedto)

        return request<SignMessagedto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressSignMessagePost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param signMessagedto  (optional)
     * @return RequestConfig
     */
    fun apiAddressSignMessagePostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, signMessagedto: SignMessagedto?) : RequestConfig<SignMessagedto> {
        val localVariableBody = signMessagedto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Address/sign-message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Address/verify-message
     * verify signed message
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param verifyMessagedto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiAddressVerifyMessagePost(nodeUrlOrApiAccessKey: kotlin.String? = null, verifyMessagedto: VerifyMessagedto? = null) : Unit {
        val localVarResponse = apiAddressVerifyMessagePostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, verifyMessagedto = verifyMessagedto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Address/verify-message
     * verify signed message
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param verifyMessagedto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiAddressVerifyMessagePostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, verifyMessagedto: VerifyMessagedto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiAddressVerifyMessagePostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, verifyMessagedto = verifyMessagedto)

        return request<VerifyMessagedto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiAddressVerifyMessagePost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param verifyMessagedto  (optional)
     * @return RequestConfig
     */
    fun apiAddressVerifyMessagePostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, verifyMessagedto: VerifyMessagedto?) : RequestConfig<VerifyMessagedto> {
        val localVariableBody = verifyMessagedto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Address/verify-message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
