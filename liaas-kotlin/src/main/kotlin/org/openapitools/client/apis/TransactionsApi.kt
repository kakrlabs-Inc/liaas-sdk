/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.BroadcastTransactiondto
import org.openapitools.client.models.CreateRawTransactiondto
import org.openapitools.client.models.CreateRawTransactiondtoV2
import org.openapitools.client.models.CreateRawTransactiondtoV3
import org.openapitools.client.models.SendFromWalletdto
import org.openapitools.client.models.SignRawTransactiondto

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class TransactionsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * POST /api/Transactions/broadcast-transaction
     * broadcast transaction on the Litecoin blockchain
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param broadcastTransactiondto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiTransactionsBroadcastTransactionPost(nodeUrlOrApiAccessKey: kotlin.String? = null, broadcastTransactiondto: BroadcastTransactiondto? = null) : Unit {
        val localVarResponse = apiTransactionsBroadcastTransactionPostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, broadcastTransactiondto = broadcastTransactiondto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Transactions/broadcast-transaction
     * broadcast transaction on the Litecoin blockchain
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param broadcastTransactiondto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiTransactionsBroadcastTransactionPostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, broadcastTransactiondto: BroadcastTransactiondto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiTransactionsBroadcastTransactionPostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, broadcastTransactiondto = broadcastTransactiondto)

        return request<BroadcastTransactiondto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiTransactionsBroadcastTransactionPost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param broadcastTransactiondto  (optional)
     * @return RequestConfig
     */
    fun apiTransactionsBroadcastTransactionPostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, broadcastTransactiondto: BroadcastTransactiondto?) : RequestConfig<BroadcastTransactiondto> {
        val localVariableBody = broadcastTransactiondto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Transactions/broadcast-transaction",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Transactions/create-raw-transaction
     * create raw transaction - returns the transaction hash
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param createRawTransactiondto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiTransactionsCreateRawTransactionPost(nodeUrlOrApiAccessKey: kotlin.String? = null, walletName: kotlin.String? = null, createRawTransactiondto: CreateRawTransactiondto? = null) : Unit {
        val localVarResponse = apiTransactionsCreateRawTransactionPostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, createRawTransactiondto = createRawTransactiondto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Transactions/create-raw-transaction
     * create raw transaction - returns the transaction hash
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param createRawTransactiondto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiTransactionsCreateRawTransactionPostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, createRawTransactiondto: CreateRawTransactiondto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiTransactionsCreateRawTransactionPostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, createRawTransactiondto = createRawTransactiondto)

        return request<CreateRawTransactiondto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiTransactionsCreateRawTransactionPost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param createRawTransactiondto  (optional)
     * @return RequestConfig
     */
    fun apiTransactionsCreateRawTransactionPostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, createRawTransactiondto: CreateRawTransactiondto?) : RequestConfig<CreateRawTransactiondto> {
        val localVariableBody = createRawTransactiondto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        walletName?.apply { localVariableHeaders["walletName"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Transactions/create-raw-transaction",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Transactions/create-raw-transaction-v2
     * create raw transaction with the address UTXOs - returns the transaction hash
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param createRawTransactiondtoV2  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiTransactionsCreateRawTransactionV2Post(nodeUrlOrApiAccessKey: kotlin.String? = null, createRawTransactiondtoV2: CreateRawTransactiondtoV2? = null) : Unit {
        val localVarResponse = apiTransactionsCreateRawTransactionV2PostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, createRawTransactiondtoV2 = createRawTransactiondtoV2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Transactions/create-raw-transaction-v2
     * create raw transaction with the address UTXOs - returns the transaction hash
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param createRawTransactiondtoV2  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiTransactionsCreateRawTransactionV2PostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, createRawTransactiondtoV2: CreateRawTransactiondtoV2?) : ApiResponse<Unit?> {
        val localVariableConfig = apiTransactionsCreateRawTransactionV2PostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, createRawTransactiondtoV2 = createRawTransactiondtoV2)

        return request<CreateRawTransactiondtoV2, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiTransactionsCreateRawTransactionV2Post
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param createRawTransactiondtoV2  (optional)
     * @return RequestConfig
     */
    fun apiTransactionsCreateRawTransactionV2PostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, createRawTransactiondtoV2: CreateRawTransactiondtoV2?) : RequestConfig<CreateRawTransactiondtoV2> {
        val localVariableBody = createRawTransactiondtoV2
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Transactions/create-raw-transaction-v2",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Transactions/create-raw-transaction-v3
     * create raw transaction with the service Fee address attached - returns the transaction hash
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param createRawTransactiondtoV3  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiTransactionsCreateRawTransactionV3Post(nodeUrlOrApiAccessKey: kotlin.String? = null, walletName: kotlin.String? = null, createRawTransactiondtoV3: CreateRawTransactiondtoV3? = null) : Unit {
        val localVarResponse = apiTransactionsCreateRawTransactionV3PostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, createRawTransactiondtoV3 = createRawTransactiondtoV3)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Transactions/create-raw-transaction-v3
     * create raw transaction with the service Fee address attached - returns the transaction hash
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param createRawTransactiondtoV3  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiTransactionsCreateRawTransactionV3PostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, createRawTransactiondtoV3: CreateRawTransactiondtoV3?) : ApiResponse<Unit?> {
        val localVariableConfig = apiTransactionsCreateRawTransactionV3PostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, createRawTransactiondtoV3 = createRawTransactiondtoV3)

        return request<CreateRawTransactiondtoV3, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiTransactionsCreateRawTransactionV3Post
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param createRawTransactiondtoV3  (optional)
     * @return RequestConfig
     */
    fun apiTransactionsCreateRawTransactionV3PostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, createRawTransactiondtoV3: CreateRawTransactiondtoV3?) : RequestConfig<CreateRawTransactiondtoV3> {
        val localVariableBody = createRawTransactiondtoV3
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        walletName?.apply { localVariableHeaders["walletName"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Transactions/create-raw-transaction-v3",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Transactions/send-funds-from-wallet
     * Send a funds from one address to another using wallet
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param sendFromWalletdto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiTransactionsSendFundsFromWalletPost(nodeUrlOrApiAccessKey: kotlin.String? = null, walletName: kotlin.String? = null, encryptedPassphrase: kotlin.String? = null, sendFromWalletdto: SendFromWalletdto? = null) : Unit {
        val localVarResponse = apiTransactionsSendFundsFromWalletPostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, encryptedPassphrase = encryptedPassphrase, sendFromWalletdto = sendFromWalletdto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Transactions/send-funds-from-wallet
     * Send a funds from one address to another using wallet
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param sendFromWalletdto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiTransactionsSendFundsFromWalletPostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, encryptedPassphrase: kotlin.String?, sendFromWalletdto: SendFromWalletdto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiTransactionsSendFundsFromWalletPostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, encryptedPassphrase = encryptedPassphrase, sendFromWalletdto = sendFromWalletdto)

        return request<SendFromWalletdto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiTransactionsSendFundsFromWalletPost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param encryptedPassphrase  (optional)
     * @param sendFromWalletdto  (optional)
     * @return RequestConfig
     */
    fun apiTransactionsSendFundsFromWalletPostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, encryptedPassphrase: kotlin.String?, sendFromWalletdto: SendFromWalletdto?) : RequestConfig<SendFromWalletdto> {
        val localVariableBody = sendFromWalletdto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        walletName?.apply { localVariableHeaders["walletName"] = this.toString() }
        encryptedPassphrase?.apply { localVariableHeaders["encryptedPassphrase"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Transactions/send-funds-from-wallet",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/Transactions/sign-transaction
     * sign a created raw transaction - returns the signed transaction hash
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param signRawTransactiondto  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiTransactionsSignTransactionPost(nodeUrlOrApiAccessKey: kotlin.String? = null, walletName: kotlin.String? = null, signRawTransactiondto: SignRawTransactiondto? = null) : Unit {
        val localVarResponse = apiTransactionsSignTransactionPostWithHttpInfo(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, signRawTransactiondto = signRawTransactiondto)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/Transactions/sign-transaction
     * sign a created raw transaction - returns the signed transaction hash
     * 
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param signRawTransactiondto  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun apiTransactionsSignTransactionPostWithHttpInfo(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, signRawTransactiondto: SignRawTransactiondto?) : ApiResponse<Unit?> {
        val localVariableConfig = apiTransactionsSignTransactionPostRequestConfig(nodeUrlOrApiAccessKey = nodeUrlOrApiAccessKey, walletName = walletName, signRawTransactiondto = signRawTransactiondto)

        return request<SignRawTransactiondto, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiTransactionsSignTransactionPost
     *
     * @param nodeUrlOrApiAccessKey  (optional)
     * @param walletName  (optional)
     * @param signRawTransactiondto  (optional)
     * @return RequestConfig
     */
    fun apiTransactionsSignTransactionPostRequestConfig(nodeUrlOrApiAccessKey: kotlin.String?, walletName: kotlin.String?, signRawTransactiondto: SignRawTransactiondto?) : RequestConfig<SignRawTransactiondto> {
        val localVariableBody = signRawTransactiondto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        nodeUrlOrApiAccessKey?.apply { localVariableHeaders["nodeUrlOrApiAccessKey"] = this.toString() }
        walletName?.apply { localVariableHeaders["walletName"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/Transactions/sign-transaction",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
