/*
KakrLabs-SDK-Creator

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TransactionsAPIService TransactionsAPI service
type TransactionsAPIService service

type ApiApiTransactionsBroadcastTransactionPostRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	nodeUrlOrApiAccessKey *string
	broadcastTransactiondto *BroadcastTransactiondto
}

// 
func (r ApiApiTransactionsBroadcastTransactionPostRequest) NodeUrlOrApiAccessKey(nodeUrlOrApiAccessKey string) ApiApiTransactionsBroadcastTransactionPostRequest {
	r.nodeUrlOrApiAccessKey = &nodeUrlOrApiAccessKey
	return r
}

// 
func (r ApiApiTransactionsBroadcastTransactionPostRequest) BroadcastTransactiondto(broadcastTransactiondto BroadcastTransactiondto) ApiApiTransactionsBroadcastTransactionPostRequest {
	r.broadcastTransactiondto = &broadcastTransactiondto
	return r
}

func (r ApiApiTransactionsBroadcastTransactionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiTransactionsBroadcastTransactionPostExecute(r)
}

/*
ApiTransactionsBroadcastTransactionPost broadcast transaction on the Litecoin blockchain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiTransactionsBroadcastTransactionPostRequest
*/
func (a *TransactionsAPIService) ApiTransactionsBroadcastTransactionPost(ctx context.Context) ApiApiTransactionsBroadcastTransactionPostRequest {
	return ApiApiTransactionsBroadcastTransactionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) ApiTransactionsBroadcastTransactionPostExecute(r ApiApiTransactionsBroadcastTransactionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ApiTransactionsBroadcastTransactionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Transactions/broadcast-transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.nodeUrlOrApiAccessKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nodeUrlOrApiAccessKey", r.nodeUrlOrApiAccessKey, "simple", "")
	}
	// body params
	localVarPostBody = r.broadcastTransactiondto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiTransactionsCreateRawTransactionPostRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	nodeUrlOrApiAccessKey *string
	walletName *string
	createRawTransactiondto *CreateRawTransactiondto
}

// 
func (r ApiApiTransactionsCreateRawTransactionPostRequest) NodeUrlOrApiAccessKey(nodeUrlOrApiAccessKey string) ApiApiTransactionsCreateRawTransactionPostRequest {
	r.nodeUrlOrApiAccessKey = &nodeUrlOrApiAccessKey
	return r
}

// 
func (r ApiApiTransactionsCreateRawTransactionPostRequest) WalletName(walletName string) ApiApiTransactionsCreateRawTransactionPostRequest {
	r.walletName = &walletName
	return r
}

// 
func (r ApiApiTransactionsCreateRawTransactionPostRequest) CreateRawTransactiondto(createRawTransactiondto CreateRawTransactiondto) ApiApiTransactionsCreateRawTransactionPostRequest {
	r.createRawTransactiondto = &createRawTransactiondto
	return r
}

func (r ApiApiTransactionsCreateRawTransactionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiTransactionsCreateRawTransactionPostExecute(r)
}

/*
ApiTransactionsCreateRawTransactionPost create raw transaction - returns the transaction hash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiTransactionsCreateRawTransactionPostRequest
*/
func (a *TransactionsAPIService) ApiTransactionsCreateRawTransactionPost(ctx context.Context) ApiApiTransactionsCreateRawTransactionPostRequest {
	return ApiApiTransactionsCreateRawTransactionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) ApiTransactionsCreateRawTransactionPostExecute(r ApiApiTransactionsCreateRawTransactionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ApiTransactionsCreateRawTransactionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Transactions/create-raw-transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.nodeUrlOrApiAccessKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nodeUrlOrApiAccessKey", r.nodeUrlOrApiAccessKey, "simple", "")
	}
	if r.walletName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "walletName", r.walletName, "simple", "")
	}
	// body params
	localVarPostBody = r.createRawTransactiondto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiTransactionsCreateRawTransactionV2PostRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	nodeUrlOrApiAccessKey *string
	createRawTransactiondtoV2 *CreateRawTransactiondtoV2
}

// 
func (r ApiApiTransactionsCreateRawTransactionV2PostRequest) NodeUrlOrApiAccessKey(nodeUrlOrApiAccessKey string) ApiApiTransactionsCreateRawTransactionV2PostRequest {
	r.nodeUrlOrApiAccessKey = &nodeUrlOrApiAccessKey
	return r
}

// 
func (r ApiApiTransactionsCreateRawTransactionV2PostRequest) CreateRawTransactiondtoV2(createRawTransactiondtoV2 CreateRawTransactiondtoV2) ApiApiTransactionsCreateRawTransactionV2PostRequest {
	r.createRawTransactiondtoV2 = &createRawTransactiondtoV2
	return r
}

func (r ApiApiTransactionsCreateRawTransactionV2PostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiTransactionsCreateRawTransactionV2PostExecute(r)
}

/*
ApiTransactionsCreateRawTransactionV2Post create raw transaction with the address UTXOs - returns the transaction hash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiTransactionsCreateRawTransactionV2PostRequest
*/
func (a *TransactionsAPIService) ApiTransactionsCreateRawTransactionV2Post(ctx context.Context) ApiApiTransactionsCreateRawTransactionV2PostRequest {
	return ApiApiTransactionsCreateRawTransactionV2PostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) ApiTransactionsCreateRawTransactionV2PostExecute(r ApiApiTransactionsCreateRawTransactionV2PostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ApiTransactionsCreateRawTransactionV2Post")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Transactions/create-raw-transaction-v2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.nodeUrlOrApiAccessKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nodeUrlOrApiAccessKey", r.nodeUrlOrApiAccessKey, "simple", "")
	}
	// body params
	localVarPostBody = r.createRawTransactiondtoV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiTransactionsCreateRawTransactionV3PostRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	nodeUrlOrApiAccessKey *string
	walletName *string
	createRawTransactiondtoV3 *CreateRawTransactiondtoV3
}

// 
func (r ApiApiTransactionsCreateRawTransactionV3PostRequest) NodeUrlOrApiAccessKey(nodeUrlOrApiAccessKey string) ApiApiTransactionsCreateRawTransactionV3PostRequest {
	r.nodeUrlOrApiAccessKey = &nodeUrlOrApiAccessKey
	return r
}

// 
func (r ApiApiTransactionsCreateRawTransactionV3PostRequest) WalletName(walletName string) ApiApiTransactionsCreateRawTransactionV3PostRequest {
	r.walletName = &walletName
	return r
}

// 
func (r ApiApiTransactionsCreateRawTransactionV3PostRequest) CreateRawTransactiondtoV3(createRawTransactiondtoV3 CreateRawTransactiondtoV3) ApiApiTransactionsCreateRawTransactionV3PostRequest {
	r.createRawTransactiondtoV3 = &createRawTransactiondtoV3
	return r
}

func (r ApiApiTransactionsCreateRawTransactionV3PostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiTransactionsCreateRawTransactionV3PostExecute(r)
}

/*
ApiTransactionsCreateRawTransactionV3Post create raw transaction with the service Fee address attached - returns the transaction hash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiTransactionsCreateRawTransactionV3PostRequest
*/
func (a *TransactionsAPIService) ApiTransactionsCreateRawTransactionV3Post(ctx context.Context) ApiApiTransactionsCreateRawTransactionV3PostRequest {
	return ApiApiTransactionsCreateRawTransactionV3PostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) ApiTransactionsCreateRawTransactionV3PostExecute(r ApiApiTransactionsCreateRawTransactionV3PostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ApiTransactionsCreateRawTransactionV3Post")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Transactions/create-raw-transaction-v3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.nodeUrlOrApiAccessKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nodeUrlOrApiAccessKey", r.nodeUrlOrApiAccessKey, "simple", "")
	}
	if r.walletName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "walletName", r.walletName, "simple", "")
	}
	// body params
	localVarPostBody = r.createRawTransactiondtoV3
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiTransactionsSendFundsFromWalletPostRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	nodeUrlOrApiAccessKey *string
	walletName *string
	encryptedPassphrase *string
	sendFromWalletdto *SendFromWalletdto
}

// 
func (r ApiApiTransactionsSendFundsFromWalletPostRequest) NodeUrlOrApiAccessKey(nodeUrlOrApiAccessKey string) ApiApiTransactionsSendFundsFromWalletPostRequest {
	r.nodeUrlOrApiAccessKey = &nodeUrlOrApiAccessKey
	return r
}

// 
func (r ApiApiTransactionsSendFundsFromWalletPostRequest) WalletName(walletName string) ApiApiTransactionsSendFundsFromWalletPostRequest {
	r.walletName = &walletName
	return r
}

// 
func (r ApiApiTransactionsSendFundsFromWalletPostRequest) EncryptedPassphrase(encryptedPassphrase string) ApiApiTransactionsSendFundsFromWalletPostRequest {
	r.encryptedPassphrase = &encryptedPassphrase
	return r
}

// 
func (r ApiApiTransactionsSendFundsFromWalletPostRequest) SendFromWalletdto(sendFromWalletdto SendFromWalletdto) ApiApiTransactionsSendFundsFromWalletPostRequest {
	r.sendFromWalletdto = &sendFromWalletdto
	return r
}

func (r ApiApiTransactionsSendFundsFromWalletPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiTransactionsSendFundsFromWalletPostExecute(r)
}

/*
ApiTransactionsSendFundsFromWalletPost Send a funds from one address to another using wallet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiTransactionsSendFundsFromWalletPostRequest
*/
func (a *TransactionsAPIService) ApiTransactionsSendFundsFromWalletPost(ctx context.Context) ApiApiTransactionsSendFundsFromWalletPostRequest {
	return ApiApiTransactionsSendFundsFromWalletPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) ApiTransactionsSendFundsFromWalletPostExecute(r ApiApiTransactionsSendFundsFromWalletPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ApiTransactionsSendFundsFromWalletPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Transactions/send-funds-from-wallet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.nodeUrlOrApiAccessKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nodeUrlOrApiAccessKey", r.nodeUrlOrApiAccessKey, "simple", "")
	}
	if r.walletName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "walletName", r.walletName, "simple", "")
	}
	if r.encryptedPassphrase != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "encryptedPassphrase", r.encryptedPassphrase, "simple", "")
	}
	// body params
	localVarPostBody = r.sendFromWalletdto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiTransactionsSignTransactionPostRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	nodeUrlOrApiAccessKey *string
	walletName *string
	signRawTransactiondto *SignRawTransactiondto
}

// 
func (r ApiApiTransactionsSignTransactionPostRequest) NodeUrlOrApiAccessKey(nodeUrlOrApiAccessKey string) ApiApiTransactionsSignTransactionPostRequest {
	r.nodeUrlOrApiAccessKey = &nodeUrlOrApiAccessKey
	return r
}

// 
func (r ApiApiTransactionsSignTransactionPostRequest) WalletName(walletName string) ApiApiTransactionsSignTransactionPostRequest {
	r.walletName = &walletName
	return r
}

// 
func (r ApiApiTransactionsSignTransactionPostRequest) SignRawTransactiondto(signRawTransactiondto SignRawTransactiondto) ApiApiTransactionsSignTransactionPostRequest {
	r.signRawTransactiondto = &signRawTransactiondto
	return r
}

func (r ApiApiTransactionsSignTransactionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiTransactionsSignTransactionPostExecute(r)
}

/*
ApiTransactionsSignTransactionPost sign a created raw transaction - returns the signed transaction hash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiTransactionsSignTransactionPostRequest
*/
func (a *TransactionsAPIService) ApiTransactionsSignTransactionPost(ctx context.Context) ApiApiTransactionsSignTransactionPostRequest {
	return ApiApiTransactionsSignTransactionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) ApiTransactionsSignTransactionPostExecute(r ApiApiTransactionsSignTransactionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ApiTransactionsSignTransactionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/Transactions/sign-transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.nodeUrlOrApiAccessKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "nodeUrlOrApiAccessKey", r.nodeUrlOrApiAccessKey, "simple", "")
	}
	if r.walletName != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "walletName", r.walletName, "simple", "")
	}
	// body params
	localVarPostBody = r.signRawTransactiondto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
